# CSS

[TOC]



**CSS**是**层叠样式表（Cascading Style Sheets）**的简称，有时也称**CSS样式表**or**级联样式表**，CSS也是一种标记语言。

CSS主要用于设置HTML页面中的**文本内容**（字体、大小、对齐方式等）、**图片的外边**（宽高、边框样式、边距等）以及**版面的布局和外观显示样式**。

## CSS语法规范

CSS规则主要由两个部分构成：==选择器==以及==一条或多条声明==。

![image-20230209154356413](CSS.assets/image-20230209154356413.png)

- `选择器` 是用于指定CSS样式的`HTML标签`，`{}`内部是对该对象设置的具体样式。
- 属性与属性值之间以"键值对"的形式出现
- 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。
- 属性和属性值之间用英文符号`:`分开。
- 多个属性对之间用英文符号`;`分开。

## CSS代码风格

### 样式格式书写

#### ①：紧凑格式

```css
h3{ color: deeppink; font-size: 20px;}
```

#### ②：展开格式

```css
h3{
	 color: deeppink; 
    font-size: 20px;
}
```

- 展开格式更加直观，方便更改

### 大小写风格

#### ①：小写格式

```css
h3{
	 color: deeppink; 
    font-size: 20px;
}
```

#### ②：大写风格

```css
H3{
	 COLOR: DEEPPINK; 
    FONT-SIZE: 20px;
}
```

- 选择器、属性名、属性值都应该用小写（特殊情况除外），看起来更直观，易读

### 样式空格规范

```css
h3 {
	 color: deeppink; 
    font-size: 20px;
}
```

- 属性值之前，冒号之后，保留一个空格。
- 选择器与花括号之间保留一个空格。

## CSS选择器

### 选择器的作用

```html
<div>我是div</div>
<div>我是div</div>
<p>我是段落</p>
<ul>
    <li>我是ul中的li</li>
</ul>
<ol>
    <li>我是ol中的li</li>
</ol>
```

- 如何把`div`中的文字改为红色？
- 如何把第一个`div`中的文字改成红色？
- 如何把`ul`中的`li`的文字改成红色？

**选择器的作用就是根据不同需求把不同的标签选出来**。



- **选择器部分种类**

	| 选择器               | 例子            | 例子描述                                | CSS  |
	| -------------------- | --------------- | --------------------------------------- | ---- |
	| `.class`             | .intro          | 选择所有class='intro'的元素             | 1    |
	| `#id`                | #firstname      | 选择所有id="firstname"                  | 1    |
	| `*`                  | *               | 选择所有元素                            | 2    |
	| `element`            | p               | 选择所有`<p>`元素                       | 1    |
	| `element,element`    | div,p           | 选择所有`<div>`和`<p>`元素              | 1    |
	| `element element`    | div p           | 选择所有`<div>`内部的所有`<p>`元素      | 1    |
	| `element>element`    | div>p           | 选择父元素为`<div>`元素的所有`<p>`元素  | 2    |
	| `element+element`    | div+p           | 选择所有紧接在`<div>`后的`<p>`元素      | 2    |
	| `[attribute]`        | [target]        | 选择带有target属性的所有元素            | 2    |
	| `[attribute=value]`  | [target=_blank] | 选择target="_blank"的所有元素           | 2    |
	| `[attribute~=value]` | [title~=flower] | 选择title属性包含单词"flower"的所有元素 | 2    |
	| `[attribute|=value]` | [lang\|=en]     | 选择lang属性值以"en"开头的所有元素      | 2    |
	| `:link`              | a:link          | 选择所有未被访问的链接                  | 1    |
	| `:visited`           | a:visited       | 选择所有已被访问的链接                  | 1    |
	| `:active`            | a:active        | 选择活动链接                            | 1    |

### 选择器的分类

选择器分为==**基础选择器**==和==**复合选择器**==两个大类。

#### **基础选择器**

- 基础选择器是由**单个选择器**组成的
- 基础选择器又包括：**标签选择器**、**类选择器**、**id选择器**和**通配符选择器**

#### **标签选择器**

标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式

```html
标签名{
	属性：属性值; 
}
```



​		**作用**：

- 标签选择器可以把某一类标签全部选出来，比如所有的`<div>`或者所有的`<p>`

	**优点**：

- 能快速为页面中同类型的标签统一设置样式

	**缺点**：

- 不能设计差异化样式，只能选择全部的标签

#### **类选择器**

如果想差异化不同的标签，单独选择一个或者某几个标签，可以使用类选择器。

```html
.类名{
	属性：属性值；
}
```

如：将所有拥有red类的HTML元素均改变为红色

```html
.red {
	color: red;
}
```

- 结构需要用**class**属性来调用class类的意思

	```html
	<div class='red'>变红色</div>
	```

- 类选择器使用"`.`"进行标识，后面紧跟类名（自定义）

- 可以理解为个这个标签取个名字来表示

- 长名称或词组可以使用"`-`"中横线来为选择器命名

- 不要使用纯数字、中文等命名，使用有意义的英文字母来表示

	**练习**

	用CSS画出下列盒子

	<img src="CSS.assets/image-20230211204255164.png" alt="image-20230211204255164" style="zoom:25%;" />

 ```html
 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>利用类选择器来画三色盒</title>
     <style>
         .red {
             width: 100px;
             height: 100px;
 
             /* 背景颜色 */
             background-color: red;
         }
 
         .green{
             width: 100px;
             height: 100px;
 
             background-color: green;
         }
     </style>
 </head>
 <body>
     <div class="red"></div>
     <div class="green"></div>
     <div class="red"></div>
 </body>
 </html>
 ```



#### **类选择器-多类名**

我们可以给一个标签指定**多个类名**，从而达到更多的选择目的。这些类名都可以选出这个标签。简单理解：一个标签拥有多个名字。

- 多类名的使用方式：

`<div class="red front20">张三盒子</div>`

1. 在`class`属性中书写多个类名
2. 多个类名中间用空格分开

- 多类名开发场景

1. 可以把一些标签元素相同的样式（共同的部分）放到一个类里面
2. 这些标签可以调用一些公共的类，然后再调用自己独有的类

#### id选择器

id选择器可以为标有特有id的HTML元素指定特样的样式

HTML中以`id`属性来设置id选择器，CSS中id以`#`来定义

```html
#id名 {
	属性1：属性值;
}
```

示例：

```html
<style>
    #pink {
        color: pink;
    }
</style>

<body>
    <div id="pink">张三</div>
    <div id="pink">李四</div>
</body>
```

- **id选择器**&**类选择器**の区别
	1. 一个元素可以有多个类名，但是只能有一个id（类似`名字`&`身份证号码`）
	2. 类选择器在修改样式用的最多，id选择器一般用于唯一性的页面元素上，经常与JavaScript搭配使用

#### 通配符选择器

在CSS中，通配符使用`*`定义，它表示选取页面中所有元素（标签）

```css
* {
	属性1：属性值;
}
```

- 通配符选择器不需要调用，自动给所有元素使用样式

- 特殊情况下才使用。例如：清除所有元素标签的内外边距。

	```css
	* {
		margin: 0;
		paddigng: 0;
	}
	```
	

#### 基础选择器总结

|  基础选择器  |              作用              |       特点       |        用法         |
| :----------: | :----------------------------: | :--------------: | :-----------------: |
|  标签选择器  | 选出相同的所有标签,<p>,<div>等 |  不能差异化选择  |  `p{color: red;}`   |
|   类选择器   |       选出一个或多个标签       | 可以根据需求选择 | `.nav{color: red;}` |
|   id选择器   |      一次只能选择一种标签      |  每个只出现一次  | `#nav{color: red;}` |
| 通配符选择器 |          选择所有标签          |   全选择，太多   |  `*{color: red;}`   |



## CSS字体属性

CSS Fonts（字体）属性用于定义**字体大小**、**粗细**、**文本样式**。



### $CSS$ 使用`font-family`属性定义文本的字体系列

```css
p {
    font-family: "微软雅黑";
}
div {
    font-family: Arial, "Microsoft YaHei", "微软雅黑";
}
```

- 各种字体之间必须使用英文逗号分隔开

- 一般情况下，如果有空格隔开的多单词组成的字体名称，需要添加引号 `"Microsoft YaHei"`

- 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示

- 最常见: `body { font-family: "Microsoft YaHei", tahoma, arial, "Hiragino Sans GB"; }`
    - 多字体带来更高的兼容性，执行顺序与书写顺序一致

### $CSS$ 使用`font-size`属性定义字体大小

```css
p {
  	font-size: 20px;  
}
```

- $px$ (像素)大小是我们网页最常用的单位
- 谷歌浏览器默认的文字大小为$16 \ px$
- 不同的浏览器可能默认显示的字号大小不一致，我们尽量给出一个明确大小

- 可以给`body`指定整个页面文字的大小

    - ```css
        body {
            font-size: 20px;
        }
        ```

### $CSS$ 使用`font-weight`属性设置文本字体的粗细

| 参数      | 效果                                                         |
| --------- | ------------------------------------------------------------ |
| `normal`  | 正常的字体。相当于`number`为`400`。声明此值将取消之前任何设置 |
| `bold`    | 粗体。相当于`number`为`700`                                  |
| `bolder`  | 特粗体。                                                     |
| `lighter` | 细体。                                                       |
| `number`  | `100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900`        |

```css
p {
    font-weight: bold;
}
```

- 实际开发中，更常使用数字表示粗细。

### $CSS$ 使用`font-style`属性设置文本的风格

```css
p {
    font-style: normal;
}
```

| 属性值   | 作用                               |
| -------- | ---------------------------------- |
| `normal` | 默认值，浏览器会显示标准的字体样式 |
| `italic` | 浏览器会显示斜体的字体样式         |

### 字体复合属性

字体属性可以把以上文字样式综合来写，可以更加节约代码:

```css
body {
    font: font-style font-weight font-size/line-height font-family;
    		风格			粗细		 大小		  行高	     字体
}

div {
    font: italic 700 16px "Microsoft YaHei";
}
```

- 使用`font`属性时，必须按照上面语法格式中的书写顺序，不能更换顺序，并且每个属性之间以空格隔开
- 不需要的属性可以忽略(取默认值)，但**必须保留`font-size`和`font-family`属性**，否则`font`属性不起作用

```css
div {
    font: 16px "Microsoft YaHei";
}
```



## $CSS$ 文本属性

$CSS \ \ \ \ Text$ （文本）属性，可以定义文本的外观，比如文本的颜色，对齐文本，装饰文本，文本缩进，行间距等  



### 文本颜色

`color` 属性用于定义文本的颜色

```csss
div {
	color: red;
}
```

| 表示           | 属性值                          |
| -------------- | ------------------------------- |
| 预定义的颜色值 | `red、green、blue、pink`等      |
| 十六进制       | `#FF0000, #FF6600, #29D794`     |
| RGB代码        | `rgb(255,0,0), rgb(100%,0%,0%)` |



### 对齐文本

`text-align` 属性用于设置元素内文本内容的水平对齐方式

| 属性值   | 作用         |
| -------- | ------------ |
| `left`   | 左对齐(默认) |
| `right`  | 右对齐       |
| `center` | 居中对齐     |

### 装饰文本

`text-decoration` 属性规定添加到文本的装饰。可以给文本添加下划线、删除线、上划线等。

```css
div {
    text-decoration: underline;
}
```

| 属性值         | 作用                            |
| -------------- | ------------------------------- |
| `none`         | 默认。没有装饰线(最常用)        |
| `underline`    | 下划线。链接`a`自带下划线(常用) |
| `overline`     | 上划线。(几乎不用)              |
| `line-through` | 删除线。(不常用)                |

- 链接`a`的下划线可用`none`去掉



### 文本缩进

`text-indent` 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。

```css
div {
    text-indent: 10px;
}
p {
    text-indent: 2em;
}
```

- 通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。
- `em`是一个相对单位，就是当前元素(`font-size`)一个文字的大小，如果当前元素没有设置大小，则会按照父元素的一个文字大小。 

### 行间距

`line-height` 属性用于设置行间的距离(行高)。可以控制文字行与行之间的距离。

```css
p {
    line-height: 26px;
}
```

<img src="./CSS.assets/image-20230413142356187.png" alt="image-20230413142356187" style="zoom: 33%;" />

- 改变行间距实际上是改变上下间距大小
- `tips`：**让文字的行高等于盒子的高度**，就可以让文字在当前盒子内垂直居中
    - 行高的上间距和下间距把文字挤到中间，如果行高小于盒子高度，文字会偏上；如果行高大于盒子高度，则文字偏下


## $CSS$ 的引入方式

### $CSS$ 的三种样式表	

​	按照 $CSS$ 样式书写的位置（或引入的防止）， $CSS$ 样式表可以分为三大类：

- 行内样式表（行内式）
- 内部样式表（嵌入式）
- 外部样式表 （链接式）

### 内部样式表

​	内部样式表（内嵌样式表）是写到`HTML`页面内部。是将所有的`CSS`代码抽取出来，单独放到一个`<style>`标签中。

```html
<style>
    div {
        color: red;
        font-size: 12px;
	}
</style>
```

- `<style>`标签理论上可以放在`HTML` 文档的任何地方，但一般会放在文档的`<head>`标签中
- 通过此种方式，可以方便控制当前整个页面中的元素样式设置。



### 行内样式表

​	行内样式表（内联样式表）是在元素标签内部的`style`属性中设置`CSS`样式。适合于修改简单样式。

```html
<div style="color: red; font-size: 12px;">
    Hello World
</div>
```

- `style`其实就是标签的属性

- 在双引号中间，写法要符合`CSS`规范

- 可以控制当前的标签设置样式

- 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用

- 使用行内式表设定`CSS`，通常也被称为行内式引入

    

### 外部样式表

​	实际开发都是外部样式表。适合样式比较多的情况，核心是：样式单独写到`CSS`文件中，之后把`CSS`文件引入到`HTML`页面中使用

​	步骤：

   1. 新建一个后缀名为`.css`的样式文件，把所有的`CSS`代码都放入此文件中。

   2. 在`HTML`页面中，使用`<link>`标签引入这个文件（置于`<head>`标签中）。

      `<l ink rel="stylesheet" href="css文件路径">`



## $CSS$ 的复合选择器

​		在 $CSS$ 中， 可以根据选择器的类型把选择器分为 **基础选择器** 和 **复合选择器**。复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。

- 符合选择器可以更准确、更高效地选择目标元素（标签）
- 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的
- 常用的复合选择器包括：**后代选择器** 、 **子选择器** 、 **并集选择器** 、 **伪类选择器** 等等



### 后代选择器 ($重要$)

​			**后代选择器**又称为**包含选择器**，可以选择父元素里面的子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。

```html
<ol>
    <li>ol 的孩子</li>
    <li>ol 的孩子</li>
    <li>ol 的孩子</li>
    <li>ol 的孩子</li>
    <li>ol 的孩子</li>
</ol>

<ul>
    <li>ul 的孩子</li>
    <li>ul 的孩子</li>
    <li>ul 的孩子</li>
    <li>ul 的孩子</li>
    <li>ul 的孩子</li>
</ul>
```

$$
现在我们想把<ol>标签里面的<li>选出来改成粉红色，依靠类选择器过于繁冗，\\依靠标签选择器无法排除<ul>标签内部的<li>标签，此时就需要采用 后代选择器 ，如下
$$

```html
<style>
    ol li {
        color: pink;
	}
</style>
```

语法：`元素1 元素2 { 样式声明 }`

```html
ul li {
	声明;
}
/* 选择 ul 里面的所有 li 标签元素 */
```

- 元素1 和 元素2 中间用**空格隔开**

- 元素1 是父级， 元素2 是子级， 最终选择的是 元素2
- 元素2 可以是儿子， 也可以是孙子， 只要是 元素1 的后代即可 

- 元素1 和 元素2 可以是任意的基础选择器

    - 如果出现以下情况

        ```html
        <ol>
            <li>ol 的孩子</li>
            <li>ol 的孩子</li>
            <li>ol 的孩子</li>
            <li>ol 的孩子</li>
            <li>ol 的孩子</li>
        </ol>
        
        <ul>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li><a href="#">链接</a></li>
        </ul>
        
        <ul>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li><a href="#">链接</a></li>
            <li><a href="#">链接</a></li>
            <li><a href="#">链接</a></li>
            <li><a href="#">链接</a></li>
        </ul>
        
        ```

        $$
        此时我希望将第二个<ul>标签中的<li>下的<a>选中，就不能使用标准选择器复合\\的后代选择器了，应使用含标签选择器的后代选择器
        $$

        ```html
        <style>
            .nav li a {
                color: yellow;
            }
        </style>
        
        <ul class="nav"> /* 给需要的标签加上类名 */
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li>ul 的孩子</li>
            <li><a href="#">链接</a></li>
            <li><a href="#">链接</a></li>
            <li><a href="#">链接</a></li>
            <li><a href="#">链接</a></li>
        </ul>
        ```

        

### 子选择器($重要$)

​			**子元素选择器（子选择器）**只能选择作为某元素的最近一级子元素（儿子元素）。

​			语法： `元素1 > 元素2 { 样式声明 }`

- 表示选择元素1 里面的所有直接后代（子元素）元素2

    ```html
    div > p{
    	声明;
    }
    /* 选择 div 里面所有最近一级 p 元素标签 */ 
    ```

- 元素1 和 元素2 中间用大于号($>$)隔开



### 并集选择器($重要$)

​			并集选择器可以选择多组标签，同时为他们定义相同的样式。通常用于集体声明。

​			并集选择器是各类选择器通过英文逗号($,$)连接而成，任何形式的选择器都可以作为并集选择器的一部分。

```html
<style>
    div,
    p {
        color: pink;
}
</style>
<body>
    <div>熊大</div>
    <p>熊二</p>
    <span>光头强</span>
    <ul class="pig">
        <li>小猪佩奇</li>
        <li>猪爸爸</li>
        <li>猪妈妈</li>
    </ul>
</body>
```

- 语法：`元素1,元素2 { 样式声明 }`

- 上述代码可以将` <div>熊大</div> <p>熊二</p>`两个标签标记为粉红色

- 并集选择器一般竖着书写
- 最后一个选择器后面不需要添加逗号



### 伪类选择器

​			伪类选择器用于向某些选择器添加特殊的效果， 比如给链接添加特殊效果，或选择第一个， 第 $n$ 个元素

​			伪类选择器书写最大的特点是用冒号 （`:`）表示，比如 `:hver` 、`:first-child`

#### 链接伪类选择器

```html
a:link 		/*选择所有未被访问的链接*/
a:visited	/*选择所有已被访问的链接*/
a:hover		/*选择鼠标指针位于其上的链接*/
a:active	/*选择活动链接(鼠标按下未弹起的链接)*/
```

- 为了确保生效，请按照**`LVHA`**的顺序声明 `:link :visited :hover :active`
- 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式   



#### `focus`伪类选择器

​			`:focus`伪类选择器用于获得焦点的表单元素

​			焦点就是光标，一般情况 `<input>`类表单元素才能获取，因此这个选择器也主要针对于表单元素来说

```html
input:focus { /*把获得光标的input表单元素选取出来*/
		background-color: yellow;
}
```



## $CSS$ 的元素显示模式

### 什么是元素显示模式

​			作用：网页的标签非常多，在不同的地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。

​			元素显示模式就是元素（标签）以什么方式进行显示，比如`<div>`自己占一行，比如一行可以放多个`<span>`

​			`HTML`一般分为 **块元素** 和 **行内元素** 两种类型



### 块元素

​			常见的块元素有`<h1>~<h6> 、 <p> 、 <div> 、<ul> 、 <ol> 、<li>`等，其中`<div>`标签是最典型的块元素

​			特点：

- 独占一行
- 高度、宽度、外边距以及内边距都可以控制
- 宽度默认是容器（父级宽度）的100%
- 是一个容器及盒子，里面可以放行内元素或者块级元素

​			注意：

- 文字类元素内不能使用块级元素
- `<p>`标签主要用于存放文字，因此`<p>`里面不能放块级元素，特别是不能放`<div>`
- 同理，`<h1> ~ <h6>`等都是文字类块级标签，里面也不能放其他块级元素



### 行内元素

​			常见的行内元素有`<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>`等，其中`<span>`标签是最典型的行内元素。有的地方也将行内元素成为**内联元素**

​			特点：

- 相邻行内元素在一行上，一行可以显示多个

- 高、宽直接设置是无效的

- 默认宽度就是他本身内容的宽度

- 行内元素只能容纳文本和其他行内元素

    注意：

- 链接里面不能再放链接
- 特殊情况下链接`<a>`里面可以放块级元素，但是给`<a>`转换一下块级模式最安全



### 行内块元素

​			在行内元素中有几个特殊的标签：`<img /> 、<input /> 、 <td>` ，他们同时具有块元素和行内元素的特点。有些资料称他们为行内块元素。

​			特点：

- 和相邻行内元素（行内块）在一行上，但是他们之间会留有空白缝隙，一行可以显示多个（行内元素特点）
- 默认宽度就是他们本身内容的宽度（行内元素特点）
- 高度、行高、外边距以及内边距都可以控制（块级元素特点）



### 元素显示模式转换

​			特殊情况下，我们需要元素模式的转换，简单理解：一个模式的元素需要另外一种模式的特性

​			比如想要增加链接`<a>`的触发范围

- 转换为块级元素：`display: block;`
- 转化为行内元素：`display: inline;`

- 转换为行内块：`display: inline-block;`



## $CSS 的背景

​			通过 $CSS$ 背景属性， 可以给页面元素添加背景样式

​			背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。



### 背景颜色

​			`background-color`属性定义了元素的背景颜色

​			语法：`background-color: 颜色值;`

​			颜色值：

- `transparent` 背景透明
- `color` 指定颜色（或者rgb，十六进制值）

- 一般情况下元素背景颜色默认值是`transparent`，我们也可以手动指定背景颜色为透明色



### 背景图片

​			`background-iamge`属性描述了元素的背景图像。实际开发常见于 $logo$ 或者一些装饰性的小图片或者说超大的背景图片，优点是非常便于控制位置（精灵图也是一种运用场景）

​			语法：`background-image: none | url(URL);`



### 背景平铺

​			如果需要再`HTML`页面上对背景图像进行平铺，可以使用`background-repeat`属性

​			默认情况下都是平铺的

| 参数        | 作用                       |
| ----------- | -------------------------- |
| `repeat`    | 背景图像在纵向和横向上平铺 |
| `no-repeat` | 背景图像不平铺             |
| `repeat-x`  | 背景图像在横向上平铺       |
| `repeat-y`  | 背景图像在纵向上平铺       |

- 页面元素既可以添加背景颜色也可以添加背景图片，只不过背景图片会压住背景颜色



### 背景图片位置

​				利用`background-position`属性可以改变图片在背景中的位置。

1. 参数是方位名词
    - 如果指定的两个值都是防卫名词，则两个值前后顺序无关，比如`left top` 和 `top left` 效果一致
    - 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐

2. 参数是精确单位
    - 如果参数值是精确坐标，那个第一个肯定是X坐标，第二个肯定是Y坐标
    - 如果只指定一个数值，那么该数值一定是X坐标，另一个默认垂直居中

3. 参数是混合单位
    - 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是X坐标，第二个值是Y坐标



### 背景图像固定（背景附着）

​			`background-attachment`属性设置背景图片是否固定或者随着页面的其余部分滚动

- 后期可以制作视差滚动的效果

​			`background-attachment: scroll | fixed`

- `scroll`背景图像是随对象内容滚动
- `fixed`背景图像固定



### 背景复合写法

​			为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性`background`中，从而节约代码量

​			当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：

​			`background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置`



### 背景颜色半透明

​			**$CSS3$** 为我们提供了背景颜色半透明效果

​			语法：`background: rgba(0, 0, 0, 0.3);`

- 最后一个参数是`alpha透明度`，取值范围在`0~1`之间

- 我们习惯将 0.3中的0省略掉，写为`background: rgba(0, 0, 0, .3);`

- 背景半透明是指盒子背景半透明，盒子里面的内容不受影响





## $CSS$ 的三大特性

- **$CSS$** 有三个非常重要的特性 ：`层叠性` 、 `继承性` 、`优先级` 



### 层叠性

​			相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题

​			**层叠性原则：**

- 样式冲突，遵循的原则是**就近原则**，哪个样式离结构近，就执行哪个样式。

- 样式不冲突，不会层叠



### 继承性

​			**$CSS$** 中的继承：字标签会继承父标签的某些样式，如**文本颜色**和**字号**。简单的理解就是，**子承父业**

```html
<style>
    div {
        color: pink;
	}
</style>

<body>
    <div>
        <p>
            龙生龙凤生凤，老鼠的儿子会打洞。
        </p>
    </div>
</body>
```

![image-20230414231623303](./CSS.assets/image-20230414231623303.png)

可以看到，即使未曾对`<p>`标签进行选择，其依旧继承了父级元素`<div>`的样式

- 恰当地使用继承可以简化代码，降低 $CSS$ 样式的复杂性

- 子元素可以继承父元素的样式（`text-`、`font-` 、`line-` 这些元素开头的可以继承，以及`color`属性）



#### 行高的继承

```html
<style>
    body {
        font: 12px/24px "Microsoft YaHei";
    }
</style>

<body>
    <div>div标签</div>
	<p>p标签</p>
</body>
/*此时p和div继承body的字体，文字大小，行高（24px)*/
```

另一种写法

```html
<style>
    body {
        font: 12px/1.5 "Microsoft YaHei";
    }
    div {
        font-size: 14px;
	}
    p {
        font-size: 16px;
    }
</style>

<body>
    <div>div标签</div>
	<p>p标签</p>
</body>
/*此时p和div继承body的字体，文字大小，行高为当前元素font-size的1.5倍  所以div的行高为21px
p 的行高为24px*/
```

- 行高可以跟单位，也可以不跟单位
- 如果子元素没有设置行高，则会继承父元素的行高为1.5
- 此时子元素的行高为：当前元素的`font-size`* 1.5
- `body`行高1.5，这样写法最大的优势就是子元素可以根据自己文字大小自动调整行高



### 优先级

​			当同一元素指定多个选择器时，就会有优先级的产生

- 选择器相同，则执行层叠性

- 选择器不同，则根据选择器权重执行

    

    选择器权重如下所示：

    | 选择器                | 权重    |
    | --------------------- | ------- |
    | 继承 或者 *（通配符） | 0,0,0,0 |
    | 元素选择器            | 0,0,0,1 |
    | 类选择器、伪类选择器  | 0,0,1,0 |
    | ID选择器              | 0,1,0,0 |
    | 行内样式              | 1,0,0,0 |
    | !important 重要的     | 无穷大  |

    `!important`用法 

    ```html
    <style>
        p {
            color: red!important;
        }
    </style>
    /*骤然拔高元素选择器的优先级*/
    ```

    

- 权重是由4组数字组成，但是不会有进位（有可能出现`0,0,0,99`）
- 可以理解为类选择器永远大于元素选择器，ID选择器永远大于类选择器，以此类推
- 等级判断从左到右，如果某一位数值相同，则判断下一位数值
- 继承的权重是0，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是0



#### 权重叠加

​			如果是**复合选择器**，则会有权重叠加，需要计算权重

```html
<style>
    ul li {
        color: green;
    }
    li {
        color: red;
    }
</style>

<body>
    <ul>
        <li>大猪蹄子</li>
        <li>大肘子</li>
        <li>猪尾巴</li>
    </ul>
</body>
```

- 运行发现`li`标签都为绿色字，这是因为`ul li {}`的权重为 `0,0,0,1+0,0,0,1=0,0,0,2`大于了`li {}`的权重为`0,0,0,1`，因此`li`标签被`ul li {}`指定





## 盒子模型



### 	看透网页布局的本质

​			过程：

1. 先准备好相关的网页元素，网页元素基本都是盒子（box）

2. 利用 $CSS$ 设置好盒子样式，然后摆放到相应位置

3. 往盒子里面装内容

    网页布局的核心本质：利用 $CSS$ 摆放盒子



### 盒子模型的组成

​			所谓盒子模型：就是把`HTML`页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。

​			$CSS$ 盒子模型本质上是一个盒子，封装周围的`HTML`元素，它包括：边框、外边距、内边距和实际内容

<img src="./CSS.assets/image-20230415235142471.png" alt="image-20230415235142471" style="zoom:33%;" />

### 边框(`border`)

<img src="./CSS.assets/image-20230415235348044.png" alt="image-20230415235348044" style="zoom:25%;" />
$$
从上面的图片可以看出，这个盒子的边框有颜色、粗细、实线
$$

- `border`可以设置元素的边框。边框由三部分组成：`边框宽度(粗细)`、`边框样式`、`边框颜色`

语法：`border: border-width || border-style || border-color`

| 属性           | 作用                     |
| -------------- | ------------------------ |
| `border-width` | 定义边框粗细，单位是$px$ |
| `border-style` | 边框样式                 |
| `border-color` | 边框颜色                 |

- 如果使用改复合属性定义其单个参数，则其他参数的默认值将无条件覆盖各自对应的单个属性设置
- 默认值为`medium none`，`border-color`的默认值采用文本颜色
- 符合写法没有顺序之分
- 要使用该属性，必须先设定对象的`height`或`width`属性，或者设定`position`属性为`absolute`

- 也可以单个书写

    - ```html
        border-width: 5px;
        border-style: solid;
        border-color: black;
        ```

- `style`的参数

    | 属性   | 效果     |
    | ------ | -------- |
    | none   | 无边框   |
    | solid  | 实线边框 |
    | dotted | 点线边框 |
    | dashed | 虚线边框 |

- 边框的是可以分开的，上下左右分别是`border-top/border-bottom/border-left/border-right`

#### 表格的细线边框

`border-collapse`属性控制浏览器绘制表格边框的方式，它控制相邻单元格的边框。

语法：`border-collapse: collapse;`

- $collapse$ 是**合并**的意思
- 上述语句将表格邻边边框合并在一起



#### 边框会增加盒子实际大小



### 内边距(`padding`)

​			`padding`属性用于设置内边距，即边框与内容之间的距离。

| 属性             | 作用     |
| ---------------- | -------- |
| `padding-left`   | 左内边距 |
| `padding-right`  | 右内边距 |
| `padding-top`    | 上内边距 |
| `padding-bottom` | 下内边距 |

- `padding`属性的简写

    | 情况                          | 效果                                                         |
    | ----------------------------- | ------------------------------------------------------------ |
    | `padding: 5px;`               | 上下左右都有5像素的内边距                                    |
    | `padding: 5px 10px;`          | 上下内边距为5像素，左右内边距为10像素                        |
    | `padding: 5px 10px 20px`      | 上内边距为5像素，左右内边距为10像素，下边距为20像素          |
    | `padding: 5px 10px 20px 30px` | 上边距为5像素，左内边距为10像素，下内边距为20像素，左内边距为30像素(`顺时针方向`) |


#### `padding `会增加盒子的实际大小

- 如果保证盒子大小跟效果图大小保持一致，则让`width/height`减去多出来的内边距大小即可

#### `padding`撑开盒子的好处

<img src="./CSS.assets/image-20230416133948791.png" alt="image-20230416133948791" style="zoom:33%;" />

由于盒子里面的字数不同，直接规定盒子宽度，导致盒子与内容之间的边距大小不同。

此时我们不设置盒子的宽度，直接设置内边距，即可。



#### 特殊情况，`padding`不会撑开盒子

​			如果盒子本身没有指定`width/height`属性，则此时`padding`不会撑开盒子大小



### 外边距(`margin`)

​			`margin`属性用于设置外边距，即控制盒子和盒子之间的距离

​			

| 属性            | 作用     |
| --------------- | -------- |
| `margin-left`   | 左外边距 |
| `margin-right`  | 右外边距 |
| `margin-top`    | 上外边距 |
| `margin-bottom` | 下外边距 |

- `margin`的简写方式和意义与`padding`完全一致

#### 外边距的典型应用

​			外边距可以让块级盒子`水平居中`，但是必须满足两个条件：

1. 盒子必须指定了宽度(`width`)

2. 盒子左右的外边距都设置为`auto`

#### 外边距合并

​			使用`margin`定义块元素的`垂直外边距`时，可能会出现外边距的合并

​			主要有两种情况:

- 相邻块元素垂直外边距的合并

    ```html
    <style>
        .damao, .ermao {
            width: 200px;
            height: 200px;
            bakcground-color: pink;
        }
        .damao {
            margin-bottom: 100px;
        }
        .ermap {
            margin-top: 200px;
        }
    </style>
    <body>
        <div class="damao">大毛</div>
        <div class="ermao">二毛</div>
    </body>
    ```

    这样书写后，实际上两个盒子的边距为`200px`，并不是外边距之和
    $$
    当上下相邻两个块元素（兄弟关系）相遇时，如果上面的元素有下边距margin-bottom， \\下面的元素有上边距margin-top，则他们之间的垂直间距不是margin-bottom+margin-top\\
    而是取两者之间值大者这种现象，称为相邻块元素垂直外边距的合并
    $$
    解决方案:`尽量只给一个盒子添加margin值`

- 嵌套块元素垂直外边距的塌陷

```html
<style>
    .father {
        width: 400px;
        height: 400px;
        background-color: purple;
        margin-top: 50px;
    }
    .son {
        width: 200px;
        height: 200px;
        background-color:pink;
        margin-top: 100px;
    }
</style>

<body>
    <div class="father">
        <div class="son"></div>
    </div>
</body>
```



<img src="./CSS.assets/image-20230416144944343.png" alt="image-20230416144944343" style="zoom:33%;" />

我们书写的代码实际上是希望父元素下降`50px`，而子元素在父元素之中下降`100px`，达到粉红色框在紫色框中部位置，而实际上这样只会让父元素下降`100px`。

对于两个嵌套关系（父子关系）的块元素，父元素有上外边距的同时子元素也有上外边距，此时父元素会塌陷比较大的外边距值。

<img src="./CSS.assets/image-20230416145247318.png" alt="image-20230416145247318" style="zoom:33%;" />

解决方案:

- 可以为父元素定义上边框

    ```html
    <style>
        .father {
            width: 400px;
            height: 400px;
            background-color: purple;
            margin-top: 50px;
            border: 1px solid red;//也可以透明
        }
        .son {
            width: 200px;
            height: 200px;
            background-color:pink;
            margin-top: 100px;
        }
    </style>
    
    <body>
        <div class="father">
            <div class="son"></div>
        </div>
    </body>
    ```

    <img src="./CSS.assets/image-20230416153030546.png" alt="image-20230416153030546" style="zoom:25%;" />

- 可以为父元素定义上内边距

    ```html
    <style>
        .father {
            width: 400px;
            height: 400px;
            background-color: purple;
            margin-top: 50px;
            padding: 1px;
        }
        .son {
            width: 200px;
            height: 200px;
            background-color:pink;
            margin-top: 100px;
        }
    </style>
    
    <body>
        <div class="father">
            <div class="son"></div>
        </div>
    </body>
    ```

    <img src="./CSS.assets/image-20230416153146560.png" alt="image-20230416153146560" style="zoom:25%;" />

- 可以为父元素添加`overflow: hidden`

```html
<style>
    .father {
        width: 400px;
        height: 400px;
        background-color: purple;
        margin-top: 50px;
        overflow: hidden;
    }
    .son {
        width: 200px;
        height: 200px;
        background-color:pink;
        margin-top: 100px;
    }
</style>

<body>
    <div class="father">
        <div class="son"></div>
    </div>
</body>
```

 

<img src="./CSS.assets/image-20230416153304315.png" alt="image-20230416153304315" style="zoom:25%;" />

这种情况可以避免改变盒子的大小

- 实际上还有其他方法，比如`浮动`、`固定`、`绝对定位`的盒子不会有塌陷问题

    

### 清除内外边距

​			网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。

```html
<style>
    * {
        margin: 0;
        padding: 0;
    }
</style>
```

- 行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。转化为块级或者行内块元素即可。



## $PS$ 基本操作

​			因为网页美工部分效果图都是利用  **$PS$** 来做的，所以以后我们大部分企图工作都是在 **$PS$** 里面完成。



## 圆角边框

​			在 **$CSS3$** 中，新增了圆角边框样式

​			`border-radius`属性用于设置元素的外边框圆角

​			语法：`border-radius:length;`

​			$radius$ 半径原理：（椭）园与边框的交集形成圆角效果 

<img src="./CSS.assets/image-20230416184905992.png" alt="image-20230416184905992" style="zoom:33%;" />

- 参数可以是`数值`也可以是`百分比`

- 圆角矩形可以设置圆角值是盒子高度的一半
- 该属性是一个简写属性，可以带四个数值，分别代表`左上角`、`右上角`、`右上角`、`左下角`

- 也可以带两个数值：`border-radius: 左上右下 右上左下`
- 也可以带三个数值：`border-radius: 左上 右上左下 右下`
- 也可以分开写`bordr-top-left-radius、bordr-top-right-radius、bordr-bottom-right-radius、bordr-bottom-left-radius`

## 盒子阴影

​			在 **$CSS3$** 中，新增了盒子阴影

​			我们可以使用`box-shadow`属性来为盒子添加阴影

​			语法：`box-shadow：h-shadow v-shadow blur spread color inset;`

| **值**     | **描述**                                    |
| ---------- | ------------------------------------------- |
| `h-shadow` | 必需。水平阴影的位置，允许负值              |
| `v-shadow` | 必需。垂直阴影的位置，允许负值              |
| `blur`     | 可选。模糊距离                              |
| `spread`   | 可选。阴影的尺寸                            |
| `color`    | 可选。阴影的颜色                            |
| `inset`    | 可选。将外部阴影改为内部阴影(属性值`inset`) |

- 外阴影设定`outset`但是内阴影必须书写`inset`



## 文字阴影

​			在 **$CSS3$** 中，我们可以使用`text-shadow`属性将阴影应用于文本

​			语法：`text-shadow: h-shadow v-shadow blur color;`

| 值         | 描述                           |
| ---------- | ------------------------------ |
| `h-shadow` | 必需。水平阴影的位置，允许负值 |
| `v-shadow` | 必需。垂直阴影的位置，允许负值 |
| `blur`     | 可选。模糊的距离               |
| `color`    | 可选。阴影的颜色               |





## 浮动



### 传统网页布局的三种方式

​			网页布局的本质——用 $CSS$ 来摆放盒子，把盒子摆放到相应位置

​			**$CSS$** 提供了三种传统布局方式（简单说，就是盒子如何进行排列顺序）：

- 普通流（标准流）
- 浮动
- 定位

### 标准流（普通流/文档流）

​			所谓标准流，就是标签按照规定好默认方式排列

1. 块级元素会独占一行，从上到下顺序排列

- 常用块级元素：`div`、`hr`、`h1~h6`、`ul`、`ol`、`dl`、`form`、`table`

2. 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行

- 常用元素：`span`、`a`、`i`、`em`等



### 为什么需要浮动？

- 提问：我们用标准流能很方便的实现如下效果吗？
    1. 如何让多个块级盒子(`div`)水平排列成一行？

<img src="./CSS.assets/image-20230416201105299.png" alt="image-20230416201105299" style="zoom: 33%;" />

- 转换`div`为行内块似乎是一种方法。但是，两个盒子之间有缝隙

<img src="./CSS.assets/image-20230416201304877.png" alt="image-20230416201304877" style="zoom: 33%;" />

2. 如何实现两个盒子的左右对齐？

    <img src="./CSS.assets/image-20230416222628210.png" alt="image-20230416222628210" style="zoom:33%;" />

- 有很多的布局效果，标准流无法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式。

- 浮动最典型的应用：可以让多个块级元素在一行内排列显示

- 网页布局第一准则：`多个块元素纵向排列找标准流，多个块元素横向排列找浮动`

### 什么是浮动

​			`float`属性用于创建浮动框，将其移动到一边，直到左边缘或者右边缘触及包含块或另一个浮动框的边缘。

​			语法：`选择器 { float: 属性值; }`

| 属性值  | 描述                 |
| ------- | -------------------- |
| `none`  | 元素不浮动（默认值） |
| `left`  | 元素向左浮动         |
| `right` | 元素向右浮动         |

### 浮动特性

1. 浮动元素会脱离标准流（脱标）
2. 浮动的元素会一行内显示并且元素顶部对齐
3. 浮动的元素会具有行内块元素的特性



#### 脱标

1. 脱离标准普通流的控制（浮）移动到指定位置（动）
2. 浮动的盒子不再保留原先的位置（人去楼空）（相当于调整图层=>可以出现重叠）

<img src="./CSS.assets/image-20230416225303666.png" alt="image-20230416225303666" style="zoom:33%;" />

3. 如果多个盒子都设置了浮动，则他们会按照属性值一行内显示并且顶端对齐排列

- 顶端对齐

<img src="./CSS.assets/image-20230416225658301.png" alt="image-20230416225658301" style="zoom:25%;" />

- 当页面大小不足时，另起一行

<img src="./CSS.assets/image-20230416225821566.png" alt="image-20230416225821566" style="zoom:25%;" />

- 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐

4. 浮动元素会具有行内块元素特性

- 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。

    - 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动之后，他的大小根据内容来决定

    - 浮动的盒子中间是没有缝隙的，是紧挨在一起的

    - 行内元素同理

        

### 浮动元素经常和标准流父级搭配使用

​			为了约束浮动元素的位置，我们网页布局一般采取的策略是：

`先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准则`

<img src="./CSS.assets/image-20230416232211547.png" alt="image-20230416232211547" style="zoom:33%;" />



### 常见问题



#### 1. 浮动和标准流的父盒子搭配

​			先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置

#### 2.一个元素浮动了，理论上其兄弟元素也要浮动

​			一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。

​			这是一个，第二个盒子浮动而其他盒子不浮动的现象：

<img src="./CSS.assets/image-20230417003041193.png" alt="image-20230417003041193" style="zoom:25%;" />

- 浮动的元素只会影响后面的标准流，不会影响前面的标准流



## 清除浮动



### 为什么要清除浮动？

​			由于父盒子在很多情况下，不方便给出高度，但是子盒子浮动又不占有位置，最后腹肌盒子高度为0时，就会影响下面的标准流盒子。

<img src="./CSS.assets/image-20230417004132817.png" alt="image-20230417004132817" style="zoom:50%;" />

- 由于浮动元素不再占用原文档流的位置，所以他会对后面的元素排版产生影响



### 清除浮动本质

- 清除浮动的本质是`清除浮动元素造成的影响`

### 清除浮动的策略

- 闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子

### 清除

​			语法：`选择器 { clear: 属性值; }`

| 属性值  | 描述                                             |
| ------- | ------------------------------------------------ |
| `left`  | 不允许左侧有浮动元素（清除左侧元素浮动的影响）   |
| `right` | 不允许右侧有浮动元素（清除右侧侧元素浮动的影响） |
| `both`  | 同时清除两侧浮动的影响                           |

- 实际工作中，几乎只使用`clear: both;`



### 清除浮动方法

1. **额外标签法**，也称隔墙法，是 $W3C$ 推荐的做法

    - 额外标签法会在浮动元素末尾添加一个空的标签。例如`<div style="clear:both"></div>`，或者其他标签(如`<br />`等)

        ```html
        <style>
                .clear {
                    clear: both;
                }
        </style>
        
        <body>
            <div class="box">
                <div class="damao">大毛</div>
                <div class="damao">大毛</div>
                <div class="clear"></div>
            </div>
        </body>
        ```

- 优点：通俗易懂，书写方便
- 缺点：添加许多无意义的标签，结构化较差

- 注意：新添加的这个空标签必须是块级元素

    

2. 父级添加`overflow`属性
    - 可以给父元素添加`overflow`属性，将其属性值设为`hidden`(最常使用）、`atuo`或`scroll`

- 优点：代码简洁

- 缺点：无法显示溢出的部分

    

3. 父级添加`:after`伪元素

    - `:after`方式是额外标签法的升级版。也是给父元素添加

        ```html
        <style>
        .clearfix:after {
        	content: "";
        	display: block;
        	height: 0;
        	clear: both;
        	visibility: hidden;
        }
        
        .clearfix {
        	*zoom: 1;
        }
        </style>
        <body>
            <div class="box clearfix">
                <div></div>
                <div></div>
            </div>
        </body>
        ```

- 优点：没有增加标签，结构更简单

- 缺点：需要照顾低版本浏览器

- 代表网站：百度、淘宝、网易等

    

4. 父级添加双伪元素

    ```html
    <style>
    .clearfix:before, .clearfix:after {
    	content:"";
    	display:table;
    }
    
    .clearfix:after {
    	clear:both;
    }
    
    .clearfix {
    	*zoom: 1;
    }
    </style>
    ```

- 优点：代码更简洁
- 缺点：需要照顾低版本浏览器
- 代表网站：小米，腾讯等



## $PS$ 切图



### 常见的图片格式

1. `jpg`图片格式：`JPEG(JPG)`对色彩信息保留较好，高清，颜色较多，我们产品类的图片经常使用`JPG`格式
2. `gif`图片格式：`GIF`格式最多只能储存256色，所以通常用来显示简单图形及字体，但是还是可以保存透明背景和动画效果，实际常用于一些图片小动画效果
3. `png`图片格式：`PNG`格式是一种新兴的网络图形格式，结合了`GIF`和`JPEG`的优点，具有储存形式丰富的特点，能够保持透明背景。如果想切成背景透明的图片，请选择`PNG`格式
4. `PSD`图片格式：`PSD`格式是 $PhotoShop$ 的专用格式，里面可以存放图层、通道、遮罩等多种设计稿。对我们前端人员来说，最大的优点就是我们可以直接从上面复制文字，获得图片，还可以测量大小和距离

## $CSS$ 属性书写顺序

1. 布局定位属性：`display/position/float/clear/visibility/overflow`（建议`display`第一个写）
2. 自身属性：`width/height/margin/padding/border/background`
3. 文本属性：`color/font/text-decoration/text-align/vertical-align/white-space/break-word`
4. 其他属性（ $CSS3$ ）：`content/cursor/border-radius/box-shadows/text-shadow/background:linear-gradient...`



## 导航栏制作

​			实际开发中，我们不会直接用链接`a`而是用`li`包含链接(`li+a`)的做法

1. `li+a`语义更清晰，一看这就是有条理的列表型内容
2. 如果直接用`a`，搜索引擎容易辨别为有堆砌关键词嫌疑（故意堆砌关键字容易被搜索引擎降权）从而影响网站排名

- 让导航栏一行显示，给`li`添加浮动，因为`li`是块级元素，需要一行显示。

- 导航栏`nav`可以不给定高度，将来可以继续添加其余文字
- 导航栏内部文字不一样多，所以做好给链接`a`左右`padding`撑开盒子，而不是指定宽度



## 定位



### 为什么需要定位

- 以下情况可以使用标准流或者浮动实现吗？

​			1. 某个元素可以自由的在一个盒子内移动位置并且压住其他盒子

<img src="./CSS.assets/image-20230418164154348.png" alt="image-20230418164154348" style="zoom: 33%;" />

 

2. 滚动窗口的时候，盒子是固定在屏幕某个位置的

<img src="./CSS.assets/image-20230418164256500.png" alt="image-20230418164256500" style="zoom:25%;" />

- 以上效果，标准流和浮动都无法快速实现，此时需要定位来实现

所以

- 浮动可以让多个块级盒子一行无缝显示，经常用于横向排列盒子
- 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子



### 定位组成

​			定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子

​			`定位 = 定位模式 + 边偏移`

​			**定位模式**用于指定一个元素在文档中的定位方式。

​			**边偏移**则决定了该元素的最终位置



#### 定位模式

​			定位模式决定元素的定位方式，它通过 $CSS$ 中的`position`属性来设置，其值可以分为五个：

| 值         | 语义         |
| ---------- | ------------ |
| `static`   | **静态**定位 |
| `relative` | **相对**定位 |
| `absolute` | **绝对**定位 |
| `fixed`    | **固定**定位 |
| `sticky`   | **粘性**定位 |



#### 边偏移

​			边偏移就是定位盒子移动到的最终位置。有`top`、`bottom`、`left`、`right`4个属性



| 属性     | 实例            | 描述                                                   |
| -------- | --------------- | ------------------------------------------------------ |
| `top`    | `top: 80px;`    | **顶部**偏移量，定义元素相对于其父元素**上边线的距离** |
| `bottom` | `bottom: 80px;` | **底部**偏移量，定义元素相对于其父元素**下边线的距离** |
| `left`   | `left: 80px;`   | **左侧**偏移量，定义元素相对于其父元素**左边线的距离** |
| `right`  | `right: 80px;`  | **右侧**偏移量，定义元素相对于其父元素**右边线的距离** |



### 静态定位(`static`)

​			静态定位是元素默认定位方式，**无定位**的意思

​			语法：`选择器 { position: static; }`

- 静态定位按照标准流的特性摆放位置，它没有边偏移



### 相对定位(`relative`)

​			相对定位是元素在移动位置的时候，是相对于**它原来的位置**来说的

​			语法：`选择器 { position: relative; }`

- 相对于自己原来的位置来移动
- 原来在标准流中的位置继续占有，后面的盒子仍然以标准流的方式对待它（`不脱标，继续保留原来的位置`)



### 绝对定位(`absolute`)

​			绝对定位是元素在移动的时候，是相当于他的祖先元素来说的

​			语法：`选择器 { position: absolute; }`

- 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位
- 如果祖先元素有定位（`相对、绝对、固定定位`），则以最近一级的有定位祖先元素为参考点移动位置
- 绝对定位不在占有原先的位置。（`脱标`）



#### 子绝父相

​			即**子级使用绝对定位，父级则需要相对定位**

- 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子
- 父盒子需要加定位限制子盒子在父盒子内的显示
- 父盒子布局时，需要占有位置，因此父亲只能是相对定位



这就是**子绝父相**的由来，所以相对定位经常用来作为绝对定位的父级。

总结：**因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位**



### 固定定位(`fixed`)

​			固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动式元素位置不改变。

​				语法：`选择器 { position: fixed; }`

- 以浏览器的可视窗口作为参照点移动元素
- 跟父元素没有任何关系
- 不随滚动条滚动
- 不再占有原先的位置（`脱标`）

- 固定定位其实可以看做是一种特殊的绝对定位

#### 固定定位小技巧

​			固定在版心右侧位置

​			小算法：

1. 让固定定位的盒子拥有属性`left:50%`。走到浏览器可视区（或版心）的一半位置
2. 让固定定位的盒子拥有属性`margin-left: 版心一半宽度距离`

​			即可让固定定位的盒子贴着版心右侧对齐



### 粘性定位(`sticky`)

​			粘性定位可以被认为是相对定位和固定定位的混合

​			语法：`选择器 { position: sticky;  top: 10px;}`

- 以浏览器的可视窗口为参照点移动元素（固定定位特点）
- 粘性定位占有原先的位置（相对定位特点）
- 必须添加`top/left/right/bottom`其中一个才有效
- 不添加按相对定位处理
- 兼容性较差，IE不支持，通常使用`javaScript`实现类似功能



### 定位叠放次序(`z-index`)

​			在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用`z-index`来控制盒子的前后次序(`z轴`)

​			语法：`选择器 { z-index: 1;}`

- 数值可以是正整数，负整数，或0，默认是`auto`，数值越大，盒子越靠上

- 如果属性值相同，则按照书写顺序，后来居上 

- 数字后面不加单位

- 只有定位的盒子才有`z-index`属性

    

### 定位の拓展



#### 绝对定位盒子居中

- 加了绝对定位的盒子不能通过`margin: 0 auto`水平居中，但是可以通过下列计算方法实现水平和垂直居中

    - 水平居中

        `left: 50%;`

        `margin-left: -一半盒子宽`

    - 垂直居中

        `top: 50;`

        `margin-top: -一半盒子高`



#### 定位特殊特性

​			绝对定位和固定定位也和浮动类似

- 行内元素添加绝对或者固定定位，可以直接设置高度和宽度。
- 块级元素添加绝对定位或者固定定位，如果不给宽度或者高度，默认大小是内容的大小



#### 绝对定位或者固定定位会完全压住盒子

- 浮动元素不同，只会压出浮动元素下面标准流的盒子，但是不会压住下面标准流盒子里面的内容（图片）
- 但是绝对定位/固定定位不同，会压住下面标准流盒子的所有内容
- 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果。文字会围绕浮动元素

- 如果一个盒子既有`left`属性也有`right`属性，则会默认执行`left`属性
- 如果一个盒子既有`top`属性也有`bottom`属性，则会默认执行`top`属性



### 元素的显示与隐藏

​			类似于网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现。

​			本质：`让一个元素在页面中隐藏或者显示出来`

#### `display`属性

​			`display`属性用于设置一个元素应如何显示

- `display: none;`隐藏对象，位置也不保留
- `display: block;`除了换为块级元素之外，同时还有显示元素的意思

####  `visibility`可见性

​			`visibility`属性用于指定一个元素应该可见还是隐藏

- `visibility: none;`元素可视
- `visibiility: hidden;`元素隐藏，但是位置保留

`overflow`溢出隐藏

​				语法：`overflow: visible | auto | hidden | scroll`

- `visible`：不剪切内容也不添加滚动条。

<img src="./CSS.assets/image-20230418204759341.png" alt="image-20230418204759341" style="zoom:25%;" />

- `hidden`：不显示超过对象尺寸的内容

<img src="./CSS.assets/image-20230418204929768.png" alt="image-20230418204929768" style="zoom:25%;" />

- `scroll`：总是显示滚动条

<img src="./CSS.assets/image-20230418205033979.png" alt="image-20230418205033979" style="zoom:25%;" />

- `auto`：在需要剪切内容时添加滚动条(溢出时才 显示滚动条)

<img src="./CSS.assets/image-20230418205136171.png" alt="image-20230418205136171" style="zoom:33%;" />

- `overflow`属性指定了如果内容溢出一个元素的框（超过其指定的高度及宽度）时，会发生什么
- 一般情况下，我们都不想让溢出内容显示出来，因为溢出部分会影响布局。但是如果有定位的盒子，请使用`overflow: hidden;`因为他会隐藏多余的部分

## 精灵图（ $sprites$ )

- 为什么需要精灵图？

<img src="./CSS.assets/image-20230418211702826.png" alt="image-20230418211702826" style="zoom:25%;" />

​			一个网页往往会应用很多小的背景图片作为装饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度

​			因此，为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了 $CSS$ 精灵技术

- 核心原理：将网页中一些小背景图像整合到一张大图当中，这样服务器只需要一次请求就可以了

### 精灵图的使用

​			这是一个精灵图

<img src="./CSS.assets/index.png" alt="img" style="zoom:33%;" />

1. 精灵技术主要针对于背景图片使用。就是把多个小图片整合到一张大图片中
2. 移动背景图片位置，此时可以使用`background-position`
3. 移动的距离就是这个图片的`x`和`y`坐标。注意与网页中的坐标有所不同（移动方向与存在方向相反）
4. 一般情况下精灵图都是负值（注意网页中的坐标：x轴右边是正值，y轴上边是正值）



## 字体图标(`iconfont`)

​			使用场景：主要用于显示网页中通用、常用的一些小图标

​			字体图标可以为前端工程师提供一种方便高校的图标使用方式，展示的是图标，本质属于字体

​			优点：

- 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求
- 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等
- 兼容性：几乎支持所有的浏览器

​			PS：字体图标不能代替精灵技术，只是对工作中图标部分技术的提升和优化



​			字体图标是一些网页常见的小图标，我们直接晚上下载即可。因此使用可以分为：

1. 字体图标的下载
    - $icomoon$ 字体库：`http://icomoon.io`
    - 阿里 $icofont$ 字库：`http://www.iconfont.cn/`
2. 字体图标的引入（引入到我们HTML页面中）
3. 字体图标的追加（以后添加新的小图标）

#### 字体图标的引入

1. 把下载包里面的`fonts`文件夹放入页面根目录

    ![image-20230419132555148](./CSS.assets/image-20230419132555148.png)

- 为什么有这几种文件呢？

    ![image-20230419132708277](./CSS.assets/image-20230419132708277.png)

- 不同的浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件
    1. $TrueType$(`.ttf`)格式：`.ttf`字体是 $Windows$ 和 $Mac$ 的最常见字体，支持这种字体的浏览器有 $IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、IOS \ Mobile、Safari4.2+$
    2. $Web\ Open \ Font \ Format$ (`.woff`)格式：`.woff`字体，支持这种字体的浏览器有$IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+$
    3. $Emvedded \ Open \ Type$ (`.eot`)格式：`.eot`字体是IE专用字体，支持这种字体的浏览器有$IE4+$
    4. $SVG$ (`.svg`)格式：`.svg`字体是基于 $SVG$ 字体渲染的一种格式，支持这种字体的浏览器有 $Chrome4+、Safari3.1+、Opera10.0.+、IOS \ Moile、Safari3.2+$

2. 在 $CSS$ 样式中全局声明字体：（简单理解把这些字体文件通过CSS引入到我们的页面中）

    一定注意字体文件路径问题

    ```html
    <style>
        @font-face {
            font-family: "icomoon";
            src: url('fonts/icomoon.eot?7kkyc2');
            src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype');
            	url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
            	url('fonts/icomoon.woff?7kkyc2') format('woff'),
            	url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
            font-weight: normal;
            font-style: normal;
    	}
    </style>
    ```

    

​			下载后，在文件夹中的`.css`文件直接复制即可

<img src="./CSS.assets/image-20230419134152702.png" style="zoom: 33%;" />

3. 在`HTML`标签内添加小图标

    ![image-20230419134433998](./CSS.assets/image-20230419134433998.png)

`<span>口</span>` 引入

4. 给标签声明字体
    - 作为文字，你也可以指定大小和颜色

![image-20230419134717172](./CSS.assets/image-20230419134717172.png)



## $CSS$ 三角

​			网页中常见的一些三角形，使用 $CSS$  直接画出来就可以，不必做成图片或者字体图标。

```html
<style>
    .box {
        width: 0;
        height: 0;
        border-top: 10px solid pink;
        border-bottom: 10px solid black;
        border-right: 10px solid skyblue;
        border-left: 10px solid yellow;
}
</style>
<body>
    <div class="box"></div>
</body>
```

会出现下列图像：

![image-20230420141555675](./CSS.assets/image-20230420141555675.png)

如果要创建三角，只需要让其余三个角的颜色为透明即可

```html
 <style>
        .box {
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-right: 10px solid skyblue;
        }
    </style>
```



![image-20230420141707446](./CSS.assets/image-20230420141707446.png)


## $CSS$ 用户界面样式

​		所谓界面样式，就是更改一些用户操作的样式，以便提高更好的用户体验

- 更改用户的鼠标样式
- 表单轮廓
- 防止表单域拖拽



### 鼠标样式(`cursor`)

​			`选择器 { cursor: pointer; }`

​			设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状

| 属性值        | 描述      |
| ------------- | --------- |
| `default`     | 小白 默认 |
| `pointer`     | 小手      |
| `move`        | 移动      |
| `text`        | 文本      |
| `not-allowed` | 禁止      |

### 轮廓线(`outline`)

​			<img src="./CSS.assets/image-20230420144209053.png" alt="image-20230420144209053" style="zoom:33%;" />

​			当鼠标点击`input`输入框时，输入框出现蓝色轮廓线

​			给表单添加上`outline: 0;`或者`outline: none;`样式后，就可以去掉默认的蓝色边框

### 防止拖拽文本域(`resize`)

​			`textarea { resize: none; }`



## `vertical-align`属性应用

​			$CSS$ 的`vertical-align`属性使用场景：经常用于设置图片或者表单（行内块元素）和文字垂直对齐

​			用于设置一个元素的垂直对齐方式，但是他只针对与行内元素或者行内块元素有效。

​			语法：`vertical-align: baseline | top | middle | bottom`

| 值         | 描述                                 |
| ---------- | ------------------------------------ |
| `baseline` | 默认。元素放在父元素的基线上         |
| `top`      | 把元素顶端与行中最高元素的顶端对齐   |
| `middle`   | 把此元素放置在父元素的中部           |
| `bottom`   | 把元素的顶端与行中最低元素的顶端对齐 |

<img src="./CSS.assets/image-20230420150435820.png" alt="image-20230420150435820" style="zoom:50%;" />

​		

- 图片、表单都属于行内块元素，默认的`vertical-align`是基线对齐

​			此时可以给图片、表单这些行内快元素的`vertical-align`属性设置为`middle`就可以让文字和图片垂直居中对齐了

#### `vertical-align`属性解决图片底部默认空白缝隙问题

​	<img src="./CSS.assets/image-20230420152921608.png" alt="image-20230420152921608" style="zoom:33%;" />

​			

给图片父元素盒子加上边框后，发现图片下方有白色空隙

这是因为图片默认基线对齐

解决方法：

- 给图片添加`vertical-align: middle | top | bottom`等（非基线对齐即可）（更推荐使用）
- 把图片转换成块级元素`display: blocl;`



## 溢出文字省略号显示

### 单行文本溢出显示省略号

​			必须满足三个条件：

- 先强制显示一行内文本：`whitle-space: nowrap`(默认`normal`自动换行)
- 超出部分隐藏：`overflow: hidden;`
- 文字用省略号代替：`text-overflow: ellipsis;`

### 多行文本溢出显示省略号

​			多行文本溢出显示省略号，有较大兼容性问题，适合于`webkit`浏览器或移动端（较多也是`webkit`内核）

```html
<style>
    选择器 {
        overflow: hidden;
        text-overflow: ellipsis;
        /*弹性伸缩盒子模型显示*/
        display: -webkit-box;
        /*限制一个块元素显示的文本的行数*/
        -webkit-line-clamp: 2;
        /*设置或检索伸缩盒对象的子元素的排列方式*/
        -weblit-box-orient: vertical;
    }
</style>
```





## 常见布局技巧

### `margin`负值运用

​			

在淘宝网的物品界面

<img src="./CSS.assets/image-20230420160226872.png" alt="image-20230420160226872" style="zoom: 25%;" />

每个物品栏都有一个边框，但如果用`boder: 1px`，则会出现`1+1=2`的下列效果

<img src="./CSS.assets/image-20230420160201114.png" alt="image-20230420160201114" style="zoom:25%;" />

如果我们将右边盒子的`margin-left`设置成`-1px`

<img src="./CSS.assets/image-20230420160443448.png" alt="image-20230420160443448" style="zoom:25%;" />

就可以让右边的盒子压住左边的盒子，从而形成`1+1=1`的效果（先浮动，再`-1px`）

- 如果想实现鼠标放在界面上，界面出现四个边框，就需要提高该盒子的层器（如果没有定位，则加相对定位（保留位置），如果有定位，则添加`z-index`）



### 文字围绕浮动元素

​			巧妙运用浮动元素不会压住文字的特性

<img src="./CSS.assets/image-20230420161930467.png" alt="image-20230420161930467" style="zoom:33%;" />

实现这样一个效果

```html
<style>
    * {
        margin: 0;
        padding: 0;
    }
    .box{
        width: 300px;
        height: 70px;
        background-color: #fff;
        margin: 0 auto;
    }
    .pic {
        float: left;
        width: 120px;
        height: 60px;
        margin-right: 5px;
    }
    .pic img {
        width: 100%;
    }
</style>
<div class="box">
    <div class="pic">
        <img src="#" alt="sss">
    </div>
    <p>【集锦】热身赛-巴西0-1秘鲁 内马尔替补两人血染赛场</p>
</div>
```



### 行内块巧妙运用

​			

<img src="./CSS.assets/image-20230420163031508.png" alt="image-20230420163031508" style="zoom:33%;" />

```html
<style>
    * {
        margin: 0;
        padding: 0;
    }

    .box {
        text-align: center;
    }

    .box a {
        display: inline-block;
        width: 36px;
        height: 36px;
        background-color: #f7f7f7;
        border: 1px solid #ccc;
        text-align: center;
        line-height: 36px;
        text-decoration: none;
        color: #333333;
    }

    .box .prev,
    .box .next {
        width: 80px;
    }

    .box .current,
    .box .elp {
        background-color: #fff;
        border: none;
    }

    .box input {
        height: 36px;
        width: 45px;
        border: 1px solid #ccc;
        outline: none;
    }

    .box button {
        width: 60px;
        height: 36px;
        background-color: #f7f7f7;
        border: 1px solid #ccc;
    }
</style>
<body>
    <div class="box">
        <a href="#" class="prev">&lt;&lt;上一页</a>
        <a href="#">1</a>
        <a href="#" class="current">2</a>
        <a href="#">3</a>
        <a href="#">4</a>
        <a href="#">5</a>
        <a href="#">6</a>
        <a href="#">7</a>
        <a href="#">8</a>
        <a href="#" class="elp">...</a>
        <a href="#" class="next">&gt;&gt;下一页</a>
        到第
        <input type="text" class="text">
        页
        <button>确定</button>
    </div>
</body>
```



### 三角强化

<img src="./CSS.assets/image-20230420170059610.png" alt="image-20230420170059610" style="zoom:33%;" />

要实现上述三角

```html
<style>
    .box {
     	width: 0;
        height: 0;
        border-top: 100px solid pink;
        border-right: 50px solid skyblue;
    }
</style>
<body>
    <div class="box"></div>
</body>
```

即可出现下列图像，此时将多余部分设置为`transparent`即可

![image-20230420170754872](./CSS.assets/image-20230420170754872.png)

实现：

```html
    <style>
    *{
        margin: 0;
        padding: 0;
    }
    .price {
        width: 160px;
        height: 24px;
        border: 1px solid red;
        margin: 0 auto;
        line-height: 24px;
    }

    .miaosha {
        position: relative;
        float: left;
        width: 90px;
        height: 100%;
        background-color: red;
        text-align: center;
        color:#fff;
        font-weight: 700;
        margin-right: 8px;
    }
    .miaosha i {
        position: absolute;
        top:0;
        right: 0;
        width: 0;
        height: 0;
        border-color: transparent #fff transparent transparent;
        border-style: solid;
        border-width: 24px 10px 0 0;
    }
    .origin {
        font-size: 12px;
        color:gray;
        text-decoration: line-through;
    }
</style>
<body>
    <div class="box1"></div>
    <div class="price">
        <span class="miaosha">
            ¥1650
            <i></i>
        </span>
        <span class="origin">¥6666</span>
    </div>
</body>
```

![image-20230420172213773](./CSS.assets/image-20230420172213773.png)



### $CSS$ 初始化

​			不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对 $CSS$ 初始化

​			简单理解： $CSS$ 初始化是指重设浏览器样式（也成为 $CSS \ \ reset$

​			每个网页都必须首先进行 $CSS$ 初始化





## $CSS3$ 的新特性

​				$CSS3$ 给我们新增了选择器，可以更加便捷，更加自由的选择目标元素。

- 属性选择器
- 结构伪类选择器
- 伪元素选择器





### 属性选择器

​			属性选择器可以根据元素的特定属性来选择元素。这样就可以不用借助与类或者id选择器

| 选择符          | 简介                                        |
| --------------- | ------------------------------------------- |
| `E[att]`        | 选择具有`att`属性的`E`元素                  |
| `E[att="val"]`  | 选择具有`att`属性且属性值等于`val`的`E`元素 |
| `E[att^="val"]` | 匹配具有`att`属性且值以`val`开头的`E`元素   |
| `E[att$="val"]` | 匹配具有`att`属性且值以`val`即为的`E`元素   |
| `E[att*="val"]` | 匹配具有`att`属性且值中含有`val`的`E`元素   |

- 类选择器、属性选择器 、伪类选择器，权重为10



### 结构伪类选择器

​			结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择器里面的子元素

| 选择符             | 简介                           |
| ------------------ | ------------------------------ |
| `E:first-child`    | 匹配父元素中的第一个子元素`E`  |
| `E:last-child`     | 匹配父元素中最后一个`E`元素    |
| `E:nth-child(n)`   | 匹配父元素中的第`n`个子元素`E` |
| `E:first-of-type`  | 指定类型`E`的第一个            |
| `E:last-of-type`   | 指定类型`E`的最后一个          |
| `E:nth-of-type(n)` | 指定类型`E`的第`n`个           |

- `nth-child(n)`选择某个父元素的一个或多个特定的子元素
    - `n`可以是**数字**，**关键字**和**公式**
    - `n`如果是数字，就是选择第`n`个子元素，里面数字从`1`开始
    - `n`可以是关键字：`even`偶数，`odd`奇数
    - `n`可以是公式，常见的公式如下（`n`如果是公式，则从`0`开始计算，但是第`0`个元素或者超出了元素个数会被忽略）
        1. `n`即可选择所有的孩子
        2. `2n` 偶数
        3. `2n+1` 奇数
        4. `5n` 5 10 15 ...
        5. `n+5` 从第五个开始（包含第五个）到最后
        6. `-n+5` 前五个，（包含第五个）...

- `nth-child()`会将父元素所有的子元素排序

    例如：

    ```html
    <style>
        section div:nth-child(1) {
            background-color: red;
        }
    </style>
    <section>
        <p>光头强</p> 	   //1
        <div>熊大</div>	//2
        <div>熊二</div>	//3
    </section>
    ```

    此时不会选出任何一个元素，因为第一个孩子不是`<div>`

- `nth-of-type()`与`nth-child()`不同，会将不同类型的子元素排序

    ```html
    <style>
        section div:nth-of-type(1) {
            background-color: red;
        }
    </style>
    <section>
        <p>光头强</p> 	   //1
        <div>熊大</div>	//2
        <div>熊二</div>	//3
    </section>
    ```

    此时就能将第一个`<div>`标签`<div>熊大</div>`选择出来



### 伪元素选择器

​			伪元素选择器可以帮助我们利用 $CSS$ 创建新标签元素，而不需要 $HTML$ 标签，从而简化 $HTML$ 结构。  

| 选择符     | 简介                     |
| ---------- | ------------------------ |
| `::before` | 在元素内部的前面插入内容 |
| `::after`  | 在元素内部的后面插入内容 |

- `before`和`after`创建一个元素，属于行内元素
- 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素
- 语法：`element::before{}`
- `before`和`after`必须有`content`属性
- `before`在父元素内容的前面创建元素，`after`在父元素内容的后面插入元素
- 伪元素选择器和标签选择器一样，权重为`1`

#### 伪元素字体图标

```html
<style>
    div {
        position: relative;
        width: 200px;
        height: 35px;
        border: 1px solid red;
    }

    div::after {
        font-family: 'icomoon';
        position: absolute;
        content: '';
        right: 5px;
        line-height: 35px;
        color: red;
        font-size: 18px;
    }
</style>
<body>
    <div></div>
</body>
```

![image-20230421190524597](./CSS.assets/image-20230421190524597.png)

### 伪元素视频遮罩层

```html
<style>
 .tudou::before {
     display: none;
     position: absolute;
     top: 0;
     left: 0;
     width: 100%;
     height: 100%;
     background-color: rgb(0, 0, 0, .7);
 }

 .tudou:hover::before {
     display: block;
 }
</style>
```



### 伪元素清除浮动

```html
<style>
    .clearfix:after {
        content: "";
        display: block;//插入的元素必须是块级元素
        height: 0;
        clear: both;
        visibility: hidden;
    }
</style>
```

- 在`.clearfix`的盒子后面添加一个不可见的块盒子，其实也就是额外标签法的升级和优化

<img src="./CSS.assets/image-20230422120455761.png" alt="image-20230422120455761" style="zoom:33%;" />

```html
<style>
    .clearfix:before, .clearfix:after {
        content:"";
        display:table; //当做表格中的单元格显示，将二者在一行上显示
    }

    .clearfix:after {
        clear:both;
    }
</style>
```

<img src="./CSS.assets/image-20230422120704628.png" alt="image-20230422120704628" style="zoom: 25%;" />



### 盒子模型

​				$CSS3$ 中可以通过`box-sizing`来指定盒模型，有两个值：即可指定为`content-box`,`border-box`，这样我们计算盒子大小的方式就发生了改变。

​				可以分成两个情况：

- `box-sizing: content-box`，盒子大小为`width +  padding + border`（以前默认的）

- `box-sizing: border-box`，盒子大小为`width`

    如果盒子模型我们改成了`box-sizing: border-box`，那`padding`和`border`就不会撑大盒子了（前提`padding`和`border`不会超过`width`宽度）



### 其他特性

#### 图片变模糊

- **$CSS 3$** 滤镜`filter`

    `filter`属性将模糊或者颜色偏移等图形效果应用于元素。

    `filter: 函数();` 例如：`filter: blur(5px); ` `blur`模糊处理，数值越大越模糊

#### 计算盒子宽度(`width:calc`函数)

​		`calc()`，此函数能让你在声明 $CSS$ 属性值时执行一些计算

​		`width: calc(100% - 80px);`

​		括号里面可以使用`+ - * /`来进行计算

### 过渡

​			过渡(`transition`)是 $CSS3$ 中具有颠覆性的特性之一，我们可以在不使用 $Flash$ 动画或者 `JavaScript` 的情况下，当元素从一种样式变换成另一种样式时为元素添加效果。

​			过渡动画：是从一个状态，渐渐过渡到另外一个状态

​			可以让我们页面更好看，更动感十足， 虽然低版本浏览器不支持，但是不会影响页面布局

​			经常和`:hover`一起搭配使用

​			`tansition: 要过渡的属性 花费时间 运动曲线 何时开始;`

- **属性**：想要变化的 $CSS$ 属性，宽度、高度、背景颜色、内外边距都可以。如果想要所有的属性都变化过渡，				写一个`all`就可以
- **花费时间**：单位是`秒`（必须写单位），比如`0.5s`
- **运动曲线**：默认是`ease`（可以省略）

​		<img src="./CSS.assets/image-20230422132211140.png" alt="image-20230422132211140" style="zoom: 50%;" />

- **何时开始**：单位是`秒`（必须写单位）可以设置延迟出发时间 默认是`0s`（可以省略）

- 单变化：`tansition: width .5s;`

- 多变化：`tansition: height .5s, width .5s;`

    - 或者

        ```html
        <style>
            div {
                xxxxxxx....
                tansition: all .5s;
            }
            div:hover {
                xxxxxx.....
        	}
        </style>
        ```

        

    

### $2D$ 转换

​			转换`tansform`是 $CSS3$ 中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果

​			转换可以简单理解为变形

- 移动：`translate`

- 旋转：`rotate`

- 缩放：`scale`

  ​    

####  二维坐标系

 			$2D$ 转换是改变标签在二维平面上的位置和形状的一种技术

<img src="./CSS.assets/image-20230422135400571.png" alt="image-20230422135400571" style="zoom: 33%;" />

#### 移动`tanslate`

<img src="./CSS.assets/image-20230422135448945.png" alt="image-20230422135448945" style="zoom:25%;" />

​			$2D$ 移动是 $2D$ 转换里面的一种功能，可以改变元素在页面中的位置，类似定位。

​			**语法**

```css
transform: translate(x,y); 
//或者分开写
transform: translateX(n);
transform: translateY(n);
```

- 定义 $2D$ 转换中的移动，沿着 $X$ 和 $Y$ 轴移动元素

- `translate`最大的优点：不会影响到其他元素的位置

- `tanslate`中的百分比单位是相对于自身元素的

- 对行内标签没有效果

- 使盒子垂直居中，水平居中的

    - <img src="./CSS.assets/image-20230422185734360.png" alt="image-20230422185734360" style="zoom:33%;" />

    - 用此方法可以，但是如果父盒子大小变换，则子元素盒子也需要修改参数

    - 可以

        ```css
        子元素 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        ```



#### 旋转`rotate`

​			$2D$ 旋转指的是让元素在二维平面内顺时针旋转或者逆时针旋转。

​			语法：`transform: rotate(度数)`

- `rotate`里面跟度数，单位是`deg`，比如：`rotate(45deg)`
- 角度为正则顺时针，反之，角度为负则逆时针
- 默认旋转的中心点是元素的中心点

​	

#### 转换中心点`transform-origin`

​			语法：`transform-origin: x y;`

- 注意后面的参数 $X$ 和 $Y$ 用空格隔开
- $X\space Y$默认转换的中心点是元素的中心点（50% 50%）
- 还可以给 $X\space Y$ 设置**像素**或者**方位名词**（`top bottom left right center`）

#### 缩放`scale`

​			语法：`transform: scale(x,y);`

- 其中的 $X$ 和 $Y$ 用逗号分割

- `transform: scale(1,1);` ：宽和高都放大一倍，等于没有放大

- `transform: scale(2,2);`：宽和高都放大了2倍

- `transform: scale(2);`：只写一个参数，则两参数相等，相当于`scale(2,2)`

- `transform: scale(0.5,0.5);`：缩小

- `scale`缩放最大的优势：可以设置转换中心点缩放，默认是以中心点缩放的，而且不影响其他盒子

    

#### 综合写法

   			1. 同时使用多个转换，其格式为：`transform: translate() rotate() scale()...`等
   			2. 其顺序会影响转换的效果（先旋转会改变坐标轴的方向）
   			3. 当我们同时有位移和其他属性的时候，位移放在最前面



## 动画

​			动画（`animation`）是 $CSS 3$ 中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。

​			相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。

### 动画的基本使用

​			制作动画分为两步：

1. 先定义动画
2. 在使用（调用）动画 

#### 用`keyframes`定义动画（类似定义类选择器）

```css
@keyframes 动画名称 {
    0% {
        width: 100px;
    }
    100% {
        width: 200px;
    }
}
```

​			**动画序列**

- `0%`是动画的开始，`100%`是动画的完成。这样的规则就是动画序列。
- 在`@keyframes`中规定某项 $CSS$ 样式，就能创建由当前样式逐渐改变为新样式的动画效果。(关键帧）
- 动画是使元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式任意多的次数。
- 请用百分比来规定变化发生的时间，或用关键词`from`和`to`,等同于`0%`和`100%`

#### 元素使用动画

```css
选择器 {
    xxx...
    xxx...
    xxx...
    /*调用动画*/
    animation-name: 动画名称;
    /*持续时间*/
    animation-duration: 持续时间(s);
}
```



###  动画常用属性

|            属性             |                             描述                             |
| :-------------------------: | :----------------------------------------------------------: |
|         `@keyframe`         |                           规定动画                           |
|         `animation`         |      所有动画的简写属性，除了`animation-play-state`属性      |
|      `animation-name`       |                  规定`@keyframes`动画的名称                  |
|    `animation-duration`     |     规定动画完成一个周期所花费的秒或毫秒,默认是`0`(必需)     |
| `animation-timing-function` |               规定动画的速度曲线，默认是`ease`               |
|      `animation-delay`      |                 规定动画何时开始，默认是`0`                  |
| `animation-iteration-count` |       规定动画被播放的次数，默认是`1`，还有`infinite`        |
|    `animation-direction`    | 规定动画是否在下一周期逆向播放<br />默认是`normal`,`alternate`逆播放 |
|   `animation-play-state`    | 规定动画是否正在运行或暂停<br />默认是`running`，还有`paused` |
|    `animation-fill-mode`    |    规定动画结束后状态，保持`forwards`回到起始`backwards`     |

### 动画简写属性

​			`animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束状态`

### 速度曲线细节

`animation-timing-function`：规定动画的速度曲线，默认是`ease`

|      值       |                     描述                     |
| :-----------: | :------------------------------------------: |
|   `linear`    |       动画从头到尾的速度是相同的。匀速       |
|    `ease`     | 默认。动画从低速开始，然后加快，在结束前变慢 |
|   `ease-in`   |                动画以低速开始                |
|  `ease-out`   |                动画以低速结束                |
| `ease-in-out` |             动画以低速开始和结束             |
|   `steps()`   |      指定了时间函数中的间隔数量（步长）      |



## $3D$ 转换

<img src="./CSS.assets/image-20230422225100006.png" alt="image-20230422225100006" style="zoom: 33%;" />

### 三维坐标系

- $X$ 轴：水平向右					$X$ 右边是正值，左边是负值
- $Y$ 轴：垂直向下   	          $Y$ 下边是正值，上边是负值	
- $Z$ 轴：垂直屏幕                $Z$ 往外面是正值，往里面是负值



### $3D$ 位移

​			$3D$ 位移在 $2D$ 位移的基础上多加了一个可以移动的方向，就是 $Z$ 轴方向。

- `transform: translateX(n);`：仅仅是在 $X$ 轴上移动
- `transform: translateY(n);`：仅仅是在 $Y$ 轴上移动
- `transform: translateZ(n);`：仅仅是在 $Z$ 轴上移动（`translateZ`一般使用`px`单位）
- `transform: translate3d(x,y,z);` ：其中`x、y、z`分别指要移动的轴的方向的距离

### $3D$ 旋转 

​			$3D$ 旋转指可以让元素在三维平面内沿着$X$ 轴、$Y$ 轴、$Z$ 轴或者自定义轴进行旋转

​			**语法**：

- `transform: rotateX(45deg)`：沿着 $X$ 轴正方向旋转 $45°$

- `transform: rotateY(45deg)`：沿着 $Y$ 轴正方向旋转 $45°$

- `transform: rotateZ(45deg)`：沿着 $Z$ 轴正方向旋转 $45°$

- `transform: rotate3d(x,y,z,deg)`：沿着自定义轴旋转`deg`角度

    #### 左手准则

- 左手拇指指向轴正方向
- 其余手指的弯曲方向就是该元素绕着轴正方向旋转的方向

### 透视

​			透视`perspective`

​			在 $2D$ 屏幕产生近大远小视觉立体，但是只是效果是二维的

- 如果想要在网页产生 $3D$ 效果，需要透视（理解成 $3D$  物体投影在 $2D$ 平面内）
- 模拟人类的视觉位置，可认为安排一只眼睛去看
- 透视我们也称为视距：就是人的眼睛到屏幕的距离
- 距离视觉点越近的在电脑平面成像越大，越远成像越小
- 透视的单位是像素
- <img src="./CSS.assets/image-20230422230841083.png" alt="image-20230422230841083" style="zoom: 33%;" />
- 透视写在被观察元素的父盒子上面
    - `d`：就是视距
    - `z`：就是`z`轴
    - `perspective: n px`

#### `translateZ`

​			`translateZ(100px)`：仅仅是在 $Z$ 轴上移动，有了透视，就能看到`translateZ`引起的变化了

### $3D$ 呈现

<img src="./CSS.assets/image-20230423140715389.png" alt="image-20230423140715389" style="zoom:33%;" />

**$3D$呈现`transform-style`**

- 控制子元素是否开启三维立体环境

- `transform-style: flat;`子元素不开启 $3D$ 立体空间 默认

- `transform-style: preserve-3d;`子元素开启立体空间

- 代码写给父级，影响子盒子

    



## `flex`布局

- 操作方便，布局极为简单，移动端应用广泛
- $PC$ 端浏览器支持情况较差
- $IE \space 11$或更低版本，不支持或仅部分支持
- 如果是 $PC$ 端页面布局，我们通常采用传统布局
- 如果是移动端或者不考虑兼容性的 $PC$ 端页面布局，我们还是使用 $flex$ 弹性布局

### 布局原理

​			$flex$ 是 $flexible \space Box$ 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 $flex$ 布局。

- 当我们为父盒子设置`flex`以后，子元素的`float`、`clear`和`vertical-align`属性将失效
- 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = $flex$ 布局
- 采用 $flex$ 布局的元素，称为 $Flex$ 容器，简称容器。它的所有子元素自动成为容器成员，称为 $Flex$ 项目，简称"项目"
- 子容器可以横向排列也可以纵向排列 
- <img src="./CSS.assets/image-20230423211958360.png" alt="image-20230423211958360" style="zoom:33%;" />

**总结原理：**通过给父盒子添加 `flex属性`，来控制子盒子的位置和排列方式

### 常见父项属性

- `flex-direction`： 设置主轴的方向
- `justify-content`：设置主轴上子元素的排列方式
- `flex-wrap`：设置子元素是否换行
- `align-content`：设置侧轴上的子元素的排列方式（多行）
- `align-items`：设置侧轴上的子元素排列方式（单行）
- `flex-flow`：复合属性，相当于同时设置了`flex-direction`和`flex-wrap`

### `flex-direction` 设置主轴的方向

#### 主轴和侧轴

​			在`flex`布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列， $X$ 轴和$Y$ 轴

#### 属性值

​			`flex-direction` 属性决定主轴的方向（即项目排列的方向）

​			注意：主轴和侧轴是会变化的，就看`flex-direction`设置谁为主轴，剩下的就侧轴。而我们的子元素是跟着主轴来排列的

​			

| 属性值           | 说明             |
| ---------------- | ---------------- |
| `row`            | 默认值，从左到右 |
| `row-reverse`    | 从右到左         |
| `column`         | 从上到下         |
| `column-reverse` | 从下到上         |

#### `justify-content`设置主轴上子元素的排列方式

​			使用这个属性之前，一定要确定好主轴

| 属性值          | 说明                                              |
| --------------- | ------------------------------------------------- |
| `flex-start`    | 默认值。从头部开始，如果主轴是 $X$ 轴，则从左到右 |
| `flex-end`      | 从尾部开始排列                                    |
| `center`        | 在主轴居中对齐（如果主轴是 $X$ 轴则水平居中)      |
| `space-around`  | 平分剩余空间                                      |
| `space-between` | 先两边贴边 再平分剩余空间                         |

#### `flex-wrap` 设置子元素是否换行

​			默认情况下，项目都排在一条线上（又称`轴线`）上。`flex-wrap`属性定义，`flex`布局中默认是不换行的。

| 属性值   | 说明           |
| -------- | -------------- |
| `nowrap` | 默认值，不换行 |
| `wrap`   | 换行           |

#### `align-items`设置侧轴上的子元素排列方式（单行）

​			该属性是控制子项在侧轴（默认是$Y$ 轴）上的排列方式，在子项为单行的时候使用

| 属性值       | 说明                     |
| ------------ | ------------------------ |
| `flex-start` | 从上到下                 |
| `flex-end`   | 从下到上                 |
| `center`     | 挤在一起居中（垂直居中） |
| `stretch`    | 拉伸（默认               |

#### `align-content`设置侧轴上的子元素的排列方式（多行）

​			设置子项在侧轴上的排列方式并且只能用于出子项出现换行的情况（多行），在单行下没有效果。

| 属性值          | 说明                                   |
| --------------- | -------------------------------------- |
| `flex-start`    | 默认值。在侧轴的头部开始排列           |
| `flex-end`      | 在侧轴的尾部开始排列                   |
| `center`        | 在侧轴中间显示                         |
| `space-around`  | 子项在侧轴平分剩余空间                 |
| `space-between` | 子项在侧轴先分布在两头，再平分剩余空间 |
| `stretch`       | 设置子项元素高度平分父元素高度         |

#### `flex-flow`

​			`flex-flow`属性是`flex-direction`和`flex-wrap`属性的复合属性

### 子项常见属性

​			

## 渐变背景

​			`background-image`属性实现渐变背景效果

- 渐变是多个颜色逐渐变化的视觉效果

- 一般用于设置盒子的背景

    ```css
    background-image: linear-gradient(颜色1,颜色2);
    ```

    



## 响应式开发



### 原理

​			使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的

| 设备划分                 | 尺寸区间              |
| ------------------------ | --------------------- |
| 超小屏幕（手机）         | `< 768px`             |
| 小屏设备（平板）         | `>= 768px ~ <992px`   |
| 中等屏幕（桌面显示器）   | `>= 992px ~ < 1200px` |
| 宽屏设备（大桌面显示器） | `>= 1200px`           |

### 响应式布局容器

​			响应式需要一个父级作为布局容器，来配合子级元素实现变化效果

 
